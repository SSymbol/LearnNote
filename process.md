## 进程创建后如何进入Main函数：
讨论范围C/C++（native language 原生语言）
不讨论java等managed language 托管语言

### 第一步创建进程
Linux上启动进程：**fork + exec**系列函数来实现，是操作系统提供给应用程序的API函数，最终在其内部完成系统调用进入操作系统内核，从而创建一个进程。

系统内核创建进程，使用task_struct数据结构（任务），一个任务对应一个task_struct，即一个进程，同时也是内核调度单元。

后多线程兴起，Linux早期没有线程概念，Linux内核为支持多线程将多个**task_struct**合并为组，来描述一个进程，因此Linux上的线程也称为**轻量级线程**。

### 第二步加载可执行文件
fork创建进程后，子进程与父进程几乎一样，子进程执行新的程序，需调用exec系列函数对进程可执行程序进行替换。

exec调用系统封装，进入内核sys_execve来执行真正的工作。加载可执行文件到进程空间并对其进行分析，提取可执行文件的入口地址。

C/C++通过编译器生成的可执行文件Linux下ELF格式，win下是PE文件。文件头中记录了可执行文件的指令入口地址，指示程序从哪开始。

无论win linux，应用线程都会在**用户空间和内核空间**来回穿梭，可能发生系统调用、中断、异常。进入内核空间时，线程自动保存上下文（寄存器内容，如指令寄存器EIP）到线程的堆栈上，记录自己从何而来，从内核返回时，从堆上加载这些信息，回到原来的地方继续执行。

前面提到，子进程是通过sys_execve系统调用进入到内核中的，在后面完成可执行文件的分析后，拿到了ELF文件的入口地址，将会去修改原来保存在堆栈上的上下文信息，将EIP指向ELF文件的入口地址。这样等sys_execve系统调用结束时，返回到用户空间后，就能够直接转到新的程序入口开始执行代码。

所以，一个非常重要的特点是：**exec系列函数正常情况下是不会返回的，一旦进入，完成使命后，执行流程就会转向新的可执行文件入口**

Linux上支持的可执行文件格式包括：ELF、MS-DOS、COFF，除了二进制可执行文件，还支持shell脚本，使用脚本解释器程序作为入口来启动。

通过readelf指令分析ELF文件，其入口地址是_start函数，_start函数结尾调用了__libc_start_main函数，其用于初始化C/C++运行库，初始化之后调用我们的main函数。

### windows的差异
windows在创建进程环节，将fork+exec合并，通过CreateProcess在其参数中指定子进程可执行文件路径。

windows有明确的进程和线程的概念，进程用EPROCESS结构表示，线程用ETHREAD结构表示。

所以在Windows上，进程相关的工作准备就绪后，还需要单独创建一个参与内核调度的执行单元，也就是进程中的第一个线程：主线程。当然，这个工作也封装在了CreateProcess系列函数中了。

新进程的主线程创建完成后，便开始参与系统调度了。主线程从哪里开始执行呢？内核在创建时就明确进行了指定：nt!KiThreadStartup，这是一个内核函数，线程启动后就从这里开始执行。

线程从这里启动后，再通过Windows的异步过程调用APC机制执行提前插入的APC，进而将执行流程引入应用层，去执行Windows进程应用程序的初始化工作，比如一些核心DLL文件的加载（Kernel32.dll、ntdll.dll）等等。

随后，再次通过APC机制，再转向去执行可执行文件的入口点。

这后面和Linux上的机制类似，同样没有直接到main函数，而是需要先进行C/C++运行时库的初始化，这之后经过运行时函数的包装，才最终来到我们的main函数。

APC是“异步过程调用(Asyncroneus Procedure Call)”的缩写。


### ring3和ring0
Intel的x86处理器是通过Ring级别来进行访问控制的，级别共分4层，从Ring0到Ring3（后面简称R0、R1、R2、R3）。R0层拥有最高的权限，R3层拥有最低的权限。按照Intel原有的构想，应用程序工作在R3层，只能访问R3层的数据；操作系统工作在R0层，可以访问所有层的数据；而其他驱动程序位于R1、R2层，每一层只能访问本层以及权限更低层的数据。

这应该是很好的设计，这样操作系统工作在最核心层，没有其他代码可以修改它；其他驱动程序工作在R1、R2层，有要求则向R0层调用，这样可以有效保障操作系统的安全性。但现在的OS，包括Windows和Linux都没有采用4层权限，而只是使用2层——R0层和R3层，分别来存放操作系统数据和应用程序数据，从而导致一旦驱动加载了，就运行在R0层，就拥有了和操作系统同样的权限，可以做任何事情，而所谓的rootkit也就随之而生了。

rootkit在字面上来理解，是拥有“根权限”的工具。实际上，所有的内核代码都拥有根权限，当然，并不一定它们都叫做rootkit，这要看你用它来做什么。用rootkit技术开发的木马和病毒正在迅速发展，它们往往极难清除，以往杀毒软件可以轻松清除掉系统中病毒的时代似乎已经一去不复返了。

